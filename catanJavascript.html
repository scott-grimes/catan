<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border: 1px solid #d3d3d3;
    background-color: HoneyDew;
}
</style>
</head>
<body onload="startGame()">
<script>
var tileColor = {"ocean":"HoneyDew", "pasture": "white", "field" : "Khaki","mountains": "grey","hills": "LightSalmon","desert":"yellow","forest":"OliveDrab","port":"HoneyDew"};
function startGame() {
    myGameArea.start();
    drawBoard();
}
var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 500;
        this.canvas.height = 400;
        this.hexSize = 36;
        this.context = this.canvas.getContext("2d");
        this.hex = Board();
        this.roads = {};
        this.vertices = {};
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        
        //on update do something
    },clear : function(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}
function drawBoard(){
myGameArea.clear()
for(var key in myGameArea.hex){
DrawHex(myGameArea.hex[key]);
}
}
function Hex(id,x,y,type,tileVal){
    this.id = id;
    this.x = x;
    this.y = y;
    this.type = type;
    this.tileVal = tileVal;
    
}
function DrawHex(hex) {
    //center of gameboard at x_0, y_0
	var x_0 = myGameArea.canvas.width/2;
	var y_0 = myGameArea.canvas.height/2;
    var size = myGameArea.hexSize;
    //x_a,y_a are the axial coordinates of the hex
    var x_a = hex.x
    var y_a = hex.y
    
    //x,y are pixel coords of the center of the hexagon
    var x = x_0+size*(x_a+y_a/2)*Math.sqrt(3);
    var y = y_0+y_a*size*1.5;
    
    var ctx = myGameArea.context;
    ctx.lineWidth=1;
    if(hex.type!="ocean" && hex.type!="port"){
    ctx.beginPath();
    size = size*.8;
	ctx.moveTo (x,y-size);  
	ctx.lineTo (x+size*Math.sqrt(3)/2,y-size*.5);  
	ctx.lineTo (x+size*Math.sqrt(3)/2,y+size*.5);     
	ctx.lineTo (x,y+size);   
	ctx.lineTo (x-size*Math.sqrt(3)/2,y+size*.5);  
	ctx.lineTo (x-size*Math.sqrt(3)/2,y-size*.5);   
	ctx.closePath();
    ctx.stroke();
    ctx.fillStyle=tileColor[hex.type];
    ctx.fill();
    }
    if(hex.type!="ocean"){
    ctx.font="20px Georgia";
    ctx.fillStyle="black";
    
    if(hex.type=="port"){
    ctx.fillText("P",x-6,y+5);
    
    }else{
    
    ctx.fillText(String(hex.id),x-5,y+5);
    }
    }
    
}
function Board(){
  var resources = ["field","field","field","field","forest","forest","forest","forest","pasture","pasture","pasture","pasture","mountains","mountains","mountains","hills","hills","hills","desert"]
 var ports = ["ore","wheat","wood","wool","brick","generic","generic","generic","generic"]
  var tileCount = [2,3,3,4,4,5,5,6,6,8,8,9,9,10,10,11,11,12]
  
  shuffle(resources);
  shuffle(ports);
  shuffle(tileCount);
  var hexes = {};
var tiles = [[null,null,null,null,null,null,null],[null,null,null,null,null,null,null],[null,null,null,null,null,null,null],[null,null,null,null,null,null,null],[null,null,null,null,null,null,null],[null,null,null,null,null,null,null],[null,null,null,null,null,null,null]];
//places land tiles randomly into our game board. capital letters represent land tiles
    var i = 0;
    var countIndex = 0;
    var ident = 65;
    for(var row = -2;row<=2;row+=1){
      count = -Math.abs(row)+5;
      var start = -row-2;
      if(row>0){
        start = -2;
      }
      for(var col = start;col<start+count;col+=1){
        
        var tileVal = 0;
        if(resources[i]=='desert'){
          tileVal=7;
          }
        else{
          tileVal = tileCount[countIndex];
          countIndex+=1;
          }
        var id = String.fromCharCode(ident);
        var h = new Hex(id,col,row,resources[i],tileVal);
        
        hexes[id] = h;
        i+=1;
        ident+=1;
     }
    }
    
    
    
    
    var oceans = [[1,-3],[3,-3],[3,-1],[2,1],[0,3],[-2,3],[-3,2],[-3,0],[-1,-2]];
    
    var ports = [[0,-3],[2,-3],[3,-2],[3,0],[1,2],[-1,3],[-3,3],[-3,1],[-2,-1]];
    
    ident = 97; // lowercase a
    //add our empty oceans  (lowercase letters)
    for(var i = 0;i<9;i+=1){
    var xa = oceans[i][0];
    var ya = oceans[i][1];
      var h = new Hex(String.fromCharCode(ident),xa,ya,'ocean',0);
      hexes[String.fromCharCode(ident)] = h;
      ident+=1;
    }
    
    ident = 1; // number as a string
    //add our empty oceans  (lowercase letters)
    for(var i = 0;i<9;i+=1){
    var xa = ports[i][0];
	var ya = ports[i][1];
      var h = new Hex("z"+ident.toString(),xa,ya,'port',0);
      h.port = ports[i];
      hexes["z"+ident.toString()] = h;
      ident+=1;
    }
return hexes;
}
function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;
  // While there remain elements to shuffle...
  while (0 !== currentIndex) {
    // Pick a remaining element...
    var randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    // And swap it with the current element.
    var temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
}
//returns the hex object given the x and y axial coords of the hex. returns null if no hex is found
function hexFromAx(x,y){
for(var key in myGameArea.hex){
var h = myGameArea.hex[key];
if(h.x==x && h.y==y){
return h;
}
}
return null;
}
//given pixel coordinates x,y, returns the hex object which contains the point (x,y). returns null if you did not click on a valid hexagon
function pixelToHex(x,y){
	var x_0 = 4*myGameArea.hexSize;
	var y_0 = myGameArea.canvas.height/2;
	var size = myGameArea.hexSize;
    var xc = x-x_0;
    var yc = y-y_0;
	var xa = (xc * Math.sqrt(3)/3 - y / 3) / size;
    var ya = yc * 2/3 / size;
    
    
    var xf = xa;
    var zf = ya;
    var yf = -xf-zf;
    
    var rx = Math.round(xf);
    var ry = Math.round(yf);
    var rz = Math.round(zf);
    var x_diff = Math.abs(rx - xf);
    var y_diff = Math.abs(ry - yf);
    var z_diff = Math.abs(rz - zf);
    if (x_diff > y_diff && x_diff > z_diff){
        rx = -ry-rz; }
    else if(y_diff > z_diff){
        ry = -rx-rz;}
    else{
        rz = -rx-ry;}
    //rx and rz are the x and y axial coords of our hexagon
    
return hexFromAx(rx,rz);
}
function drawLine(x1, y1, x2, y2, lineWidth, color, ctx) {
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
        
 //given a hex object, return the pixels at the center of the hexagon      
function hexToPixel(hex){
var size = myGameArea.hexSize;
	var x_0 = myGameArea.canvas.width/2;
	var y_0 = myGameArea.canvas.height/2;
//x_a,y_a are the axial coordinates of the hex
    var x_a = hex.x;
    var y_a = hex.y;
    //x,y are pixel coords of the center of the hexagon
    var x = x_0+size*(x_a+y_a/2)*Math.sqrt(3);
    var y = y_0+y_a*size*1.5;
    return [x,y]
}
        
//returns the two coordinate pairs representing the line on the edge between the two hexs given
function roadBoundry(hex1, hex2){
//vector from hex 1 towards hex2
var top, bottom;
if(hex1.id>hex2.id){
top = hex1;
bottom = hex2;
}
else{
top = hex2;
bottom = hex1;
}
[xa1,ya1] = hexToPixel(top);
[xa2,ya2] = hexToPixel(bottom);
var dx = (xa2-xa1);
var dy = (ya2-ya1);
var dist = Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2));
dx = dx/dist;
dy = dy/dist;
var size = myGameArea.hexSize*.9
var angle = 20;
c = Math.cos(angle*Math.PI/180);
var s = Math.sin(angle*Math.PI/180);
var x1 = xa1+size*(dx*c-s*dy)
var y1 = ya1+size*(dx*s+c*dy);
angle = -angle;
c = Math.cos(angle*Math.PI/180);
s = Math.sin(angle*Math.PI/180);
var x2 = xa1+size*(dx*c-s*dy)
var y2 = ya1+size*(dx*s+c*dy);
return [x1,y1,x2,y2];
}
//returns the hex object given it's ID
function findHex(id){
var h = myGameArea.hex[id]
if(h!=null){ return h;}
return null;
}
//returns an array with all the id's of the neighbor of the given hex id
function neighbors(h){
var answer = [];
var axial_directions = [[1,  0], [1, -1], [ 0, -1],[-1,  0], [-1, 1], [ 0, 1]];
var x0 = h.x;
var y0 = h.y;
for(var i=0;i<6;i++){
var xa = x0+axial_directions[i][0];
var ya = y0+axial_directions[i][1];
if(hexFromAx(xa,ya)!=null){
answer.push(hexFromAx(xa,ya).id);
}
}
return answer.sort();
}
//draws a road on the edge between the two tiles given
function drawRoad(hex1,hex2){
var bounds = roadBoundry(hex1,hex2);
drawLine(bounds[0],bounds[1],bounds[2],bounds[3],8,"black",myGameArea.context);
}
//returns the coordinates of vertex between the three given hexagon ID's
function vertexBetween(idArray){
var ids = idArray.sort();
var h = myGameArea.hex;

[xa,ya] = hexToPixel(h[ids[0]]);
[x1,y1] = hexToPixel(h[ids[1]]);
[x2,y2] = hexToPixel(h[ids[2]]);
var mx = (x1+x2)/2;
var my = (y1+y2)/2;
var dx = (mx-xa);
var dy = (my-ya);
var dist = Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2));
dx = dx/dist;
dy = dy/dist;
var size = myGameArea.hexSize;
return [xa+dx*size,ya+dy*size];
}
function drawSettlement(a,b,c){
var h = myGameArea.hex;
[x,y] = vertexBetween(a,b,c);
var ctx = myGameArea.context;
ctx.beginPath();
ctx.strokeStyle = "black";
ctx.arc(x,y,10,0,2*Math.PI);
ctx.stroke();
}
function drawCity(a,b,c){
var h = myGameArea.hex;
[x,y] = vertexBetween(a,b,c);
var ctx = myGameArea.context;
ctx.beginPath();
ctx.fillStyle = "black";
ctx.arc(x,y,10,0,2*Math.PI);
ctx.fill();
}
myGameArea.canvas.addEventListener("mousedown", myMouseDown);
myGameArea.canvas.addEventListener("mousemove", myMouseMove);
function myMouseDown(evt){
drawBoard();
var r = overRoad(evt);
console.log(r)
if(r!=null){
drawRoad(r[0],r[1]);
}
else{
var h = overHex(evt)
if(h!=null){
var cityLoc = overCitySettlement(evt);
console.log(cityLoc);
if(cityLoc!=null){
	var ctx = myGameArea.context;
ctx.beginPath();
ctx.fillStyle = "black";
ctx.arc(cityLoc[0],cityLoc[1],10,0,2*Math.PI);
ctx.fill();
}
else{
highlightHex(h);
}
}
}
}
function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
      }
function myMouseMove(evt){
drawBoard();
var r = overRoad(evt);
if(r!=null){
drawRoad(r[0],r[1]);
}
else{
var h = overHex(evt)
if(h!=null){
var cityLoc = overCitySettlement(evt);
if(cityLoc!=null){
	drawCity(cityLoc);
}
else{
highlightHex(h);
}
}
}
}
function writeMessage(canvas, message) {
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, 100, 30);
        context.font = '18pt Calibri';
        context.fillStyle = 'black';
        context.fillText(message, 10, 25);
      }
      
//returns the hex the mouse is over, or null if otherwise
function overHex(evt){
var mousePos = getMousePos(myGameArea.canvas,evt);
var h = pixelToHex(mousePos.x,mousePos.y);
return h;
}
//returns the id of the road if the pixel location is overlapping a road
//returns null otherwise
function overRoad(evt){
var h = overHex(evt);
if(h == null){return;}
var mousePos = getMousePos(myGameArea.canvas,evt);
var neigh = neighbors(h);
for(var i = 0;i<neigh.length;i++){
var n = myGameArea.hex[neigh[i]];
[x1,y1,x2,y2] = roadBoundry(h,n);
var lineRect = defineLineAsRect(x1, y1, x2, y2, 20);
drawLineAsRect(lineRect, "transparent");
	// test if hit in the lineRect
            if (myGameArea.context.isPointInPath(mousePos.x, mousePos.y)) {
             return[h,n];
}
}
return null;
}
function highlightHex(hex) {
drawBoard();
if(hex == null){ return;}
    //center of gameboard at x_0, y_0
	var x_0 = myGameArea.canvas.width/2;
	var y_0 = myGameArea.canvas.height/2;
    var size = myGameArea.hexSize;
    //x_a,y_a are the axial coordinates of the hex
    var x_a = hex.x
    var y_a = hex.y
    
    //x,y are pixel coords of the center of the hexagon
    var x = x_0+size*(x_a+y_a/2)*Math.sqrt(3);
    var y = y_0+y_a*size*1.5;
    
    ctx = myGameArea.context;
    
    ctx.beginPath();
    size = size*.8;
	ctx.moveTo (x,y-size);  
	ctx.lineTo (x+size*Math.sqrt(3)/2,y-size*.5);  
	ctx.lineTo (x+size*Math.sqrt(3)/2,y+size*.5);      
	ctx.lineTo (x,y+size);   
	ctx.lineTo (x-size*Math.sqrt(3)/2,y+size*.5);  
	ctx.lineTo (x-size*Math.sqrt(3)/2,y-size*.5);   
	ctx.closePath();
    ctx.stroke();
    ctx.fillStyle="black";
    ctx.fill();
}
function drawLineAsRect(lineAsRect, color) {
            var r = lineAsRect;
            ctx = myGameArea.context;
            ctx.save();
            ctx.beginPath();
            ctx.translate(r.translateX, r.translateY);
            ctx.rotate(r.rotation);
            ctx.rect(r.rectX, r.rectY, r.rectWidth, r.rectHeight);
            ctx.translate(-r.translateX, -r.translateY);
            ctx.rotate(-r.rotation);
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
function defineLineAsRect(x1, y1, x2, y2, lineWidth) {
            var dx = x2 - x1; // deltaX used in length and angle calculations 
            var dy = y2 - y1; // deltaY used in length and angle calculations
            var lineLength = Math.sqrt(dx * dx + dy * dy);
            var lineRadianAngle = Math.atan2(dy, dx);
            return ({
                translateX: x1,
                translateY: y1,
                rotation: lineRadianAngle,
                rectX: 0,
                rectY: -lineWidth / 2,
                rectWidth: lineLength,
                rectHeight: lineWidth
            });
            }
            
//returns an array of the x,y pixel locations of the verticies touching the hex
function hexVertices(h){
var s = myGameArea.hexSize;
[xc,yc] = hexToPixel(h);
var vertices = [];
var v = [[0,1],[Math.sqrt(3)/2,.5],[-Math.sqrt(3)/2,.5],[0,-1],[-Math.sqrt(3)/2,-.5],[Math.sqrt(3)/2,-.5]];
for(var i = 0;i<6;i+=1){
vertices.push([xc+v[i][0]*s,yc+v[i][1]*s]);
}
return vertices;
}
//returns the id of the city/settlement if the pixel location is overlapping a city or settlement, null if otherwise
function overCitySettlement(evt){
var h = overHex(evt);
if(h == null){return;}
var mousePos = getMousePos(myGameArea.canvas,evt);
var verts = hexVertices(h);
for(var i = 0;i<verts.length;i++){
var CIRLCERAD = 10;
	// test if hit in the circle of radius 20
    
    
    
    var dist = Math.sqrt(Math.pow(mousePos.x-verts[i][0],2)+Math.pow( mousePos.y-verts[i][1],2));
            if (dist<CIRLCERAD) {
             return cityFromPixel(verts[i][0] , verts[i][1] );
}
}
return null;
}
//returns the three hexes which touch the city located at the given pixel location
function cityFromPixel(x,y){
//gets the closest hex to the location
var h = pixelToHex(x,y);
if(h==null){ return null; }
//gets a list of the neighbors
var neigh = neighbors(h);
//distance the city is from all the neighbors
var dists = {};
for(var i = 0;i<neigh.length;i+=1){
var n = hexToPixel(findHex(neigh[i]));
dists[neigh[i]] = Math.sqrt(Math.pow(x-n[0],2)+Math.pow(y-n[1],2));
}
//pick two lowest distances
var sortedDistances = Object.keys(dists).sort(function(a,b){return dists[a]-dists[b]})
var solution = [sortedDistances[0],sortedDistances[1],h.id]
//alphabitizes the hexes, returns the list
return solution.sort();
}
</script>

<p>Catan!</p>

</body>
</html>
